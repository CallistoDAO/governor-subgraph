"""
This entity represents a gOHM token holder that has delegated their voting power to an address.

Note: This entity only tracks direct gOHM delegations. Escrow contracts (used by Cooler V2)
are NOT included here - their delegation attribution is tracked via CoolerDelegationEvent
and CoolerDelegationBalance entities instead.
"""
type VoteDelegator @entity(immutable: false) {
  """
  Record ID.

  Format: token holder address
  """
  id: Bytes!
  """
  Address of the owner/delegator.
  """
  address: Bytes!
  """
  Delegatee record.

  Null if the votes have not been delegated.
  """
  delegatee: Voter
}

"""
This entity represents a voter that has received delegations and can cast votes.

To get a complete picture of a voter's delegations:
- Direct delegations: Query the `delegators` field (VoteDelegator entities)
- Cooler delegations: Query through `latestVotingPowerSnapshot.coolerDelegations`
- Current voting power: Query `latestVotingPowerSnapshot.votingPower`
"""
type Voter @entity(immutable: false) {
  """
  Record ID.

  Format: voter address
  """
  id: Bytes!
  """
  Voter address.
  """
  address: Bytes!
  """
  Latest voting power snapshot.
  """
  latestVotingPowerSnapshot: VoterVotingPowerSnapshot

  # Related entities
  proposalsCreated: [ProposalCreated!] @derivedFrom(field: "proposer")
  votesCasted: [VoteCast!] @derivedFrom(field: "voter")
  votingPowerSnapshots: [VoterVotingPowerSnapshot!] @derivedFrom(field: "voter")
  """
  Addresses that have delegated their voting power to this voter via direct gOHM delegation.
  Note: Does NOT include Cooler delegations - those are available via votingPowerSnapshots.coolerDelegations.
  """
  delegators: [VoteDelegator!] @derivedFrom(field: "delegatee")
}

"""
This entity represents a snapshot of a voter's voting power at a specific block.

The `votingPower` field contains the total voting power from ALL sources:
- Direct gOHM delegations from individual token holders
- Cooler V2 delegations through escrow contracts

To understand the breakdown of voting power sources:
- Query `event` for the gOHM DelegateVotesChanged event details
- Query `coolerDelegations` for Cooler-specific attribution (delegator → delegatee)
"""
type VoterVotingPowerSnapshot @entity(immutable: true) {
  """
  Record ID.

  Format: `{voter}{blockNumber}{logIndex}`
  """
  id: Bytes!
  """
  Voter address.
  """
  voter: Voter!
  """
  Voting power, the sum of all delegations.
  """
  votingPower: BigDecimal!

  """
  Block number of the snapshot.
  """
  blockNumber: BigInt!
  """
  Timestamp of the snapshot.
  """
  blockTimestamp: BigInt!

  # Related records
  """
  The gOHM DelegateVotesChanged event that triggered this snapshot.
  """
  event: DelegateVotesChanged @derivedFrom(field: "snapshot")
  """
  Cooler delegation events that contributed to this snapshot.
  Only populated for snapshots resulting from Cooler delegations.
  """
  coolerDelegations: [CoolerDelegationEvent!] @derivedFrom(field: "snapshot")
}

type NewAdmin @entity(immutable: true) {
  id: Bytes!
  oldAdmin: Bytes! # address
  newAdmin: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NewImplementation @entity(immutable: true) {
  id: Bytes!
  oldImplementation: Bytes! # address
  newImplementation: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NewPendingAdmin @entity(immutable: true) {
  id: Bytes!
  oldPendingAdmin: Bytes! # address
  newPendingAdmin: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalCanceled @entity(immutable: true) {
  """
  Record ID.

  A proposal can only be cancelled once, so the record ID can be the proposal ID and not have any clashes.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type ProposalCreated @entity(immutable: true) {
  """
  Record ID.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  proposer: Voter!
  targets: [Bytes!]! # address[]
  values: [BigInt!]! # uint256[]
  signatures: [String!]! # string[]
  calldatas: [Bytes!]! # bytes[]
  startBlock: BigInt! # uint256
  description: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!

  cancelled: ProposalCanceled @derivedFrom(field: "proposal")
  executed: ProposalExecuted @derivedFrom(field: "proposal")
  queued: ProposalQueued @derivedFrom(field: "proposal")
  vetoed: ProposalVetoed @derivedFrom(field: "proposal")
  votingStarted: ProposalVotingStarted @derivedFrom(field: "proposal")
  votes: [VoteCast!] @derivedFrom(field: "proposal")
}

type ProposalExecuted @entity(immutable: true) {
  """
  Record ID.

  A proposal can only be executed once, so the record ID can be the proposal ID and not have any clashes.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type ProposalQueued @entity(immutable: true) {
  """
  Record ID.

  A proposal can only be queued once, so the record ID can be the proposal ID and not have any clashes.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  eta: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type ProposalThresholdSet @entity(immutable: true) {
  id: Bytes!
  oldProposalThreshold: BigInt! # uint256
  newProposalThreshold: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalVetoed @entity(immutable: true) {
  """
  Record ID.

  A proposal can only be vetoed once, so the record ID can be the proposal ID and not have any clashes.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type ProposalVotingStarted @entity(immutable: true) {
  """
  Record ID.

  A proposal can only have voting started once, so the record ID can be the proposal ID and not have any clashes.

  Format: `{proposalId}`
  """
  id: String!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type VetoGuardianSet @entity(immutable: true) {
  id: Bytes!
  oldGuardian: Bytes! # address
  newGuardian: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VoteCast @entity(immutable: true) {
  """
  Record ID.

  Format: `{proposalId}-{voter}-{transactionHash}-{logIndex}`
  """
  id: String!
  voter: Voter!
  proposalId: BigInt! # uint256
  support: Int! # uint8
  votes: BigDecimal!
  reason: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  proposal: ProposalCreated!
}

type VotingDelaySet @entity(immutable: true) {
  id: Bytes!
  oldVotingDelay: BigInt! # uint256
  newVotingDelay: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VotingPeriodSet @entity(immutable: true) {
  id: Bytes!
  oldVotingPeriod: BigInt! # uint256
  newVotingPeriod: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WhitelistAccountExpirationSet @entity(immutable: true) {
  id: Bytes!
  account: Bytes! # address
  expiration: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WhitelistGuardianSet @entity(immutable: true) {
  id: Bytes!
  oldGuardian: Bytes! # address
  newGuardian: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DelegateChanged @entity(immutable: true) {
  """
  Record ID.

  Format: `{delegator}{blockNumber}{logIndex}`
  """
  id: Bytes!
  """
  Address delegating voting power.
  """
  delegator: VoteDelegator!
  """
  The previous delegatee.
  """
  previousDelegatee: Voter
  """
  The new delegatee.
  """
  newDelegatee: Voter

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

"""
This entity records the event emitted when the voting power delegated to a delegatee changes.

Due to a limitation in the emitted event, it is not possible to determine the delegator.
"""
type DelegateVotesChanged @entity(immutable: true) {
  """
  Record ID.

  Format: `{delegatee}{blockNumber}{logIndex}`
  """
  id: Bytes!

  """
  Address receiving delegated voting power.
  """
  delegatee: Voter!
  """
  Previous voting power contributed by the delegator.
  """
  previousBalance: BigDecimal!
  """
  New voting power contributed by the delegator.
  """
  newBalance: BigDecimal!
  """
  Voting power snapshot record.
  """
  snapshot: VoterVotingPowerSnapshot!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

"""
This entity tracks the mapping between Cooler DelegateEscrow contracts and their delegatee addresses.
Created when a new escrow is deployed via DelegateEscrowFactory. This is a contract-level
mapping (escrow address → delegatee) and is immutable since each escrow is created once per delegatee.
"""
type CoolerDelegateEscrow @entity(immutable: true) {
  """
  Record ID.

  Format: escrow contract address
  """
  id: Bytes!
  """
  The escrow contract address.
  """
  escrow: Bytes!
  """
  The delegatee receiving voting power from this escrow.
  """
  delegatee: Voter!
  """
  Block when the escrow was created.
  """
  blockNumber: BigInt!
  """
  Timestamp when the escrow was created.
  """
  blockTimestamp: BigInt!
}

"""
This entity records individual Cooler V2 delegation events, providing attribution for
delegations made through the DelegateEscrow system. Each event is immutable and links
to the VoterVotingPowerSnapshot that resulted from this delegation change.

Unlike direct gOHM delegations where the delegator is known, Cooler delegations flow through
escrow contracts. This entity captures the original delegator who deposited collateral.
"""
type CoolerDelegationEvent @entity(immutable: true) {
  """
  Record ID.

  Format: {blockNumber}-{logIndex}
  """
  id: String!
  """
  The original Cooler V2 delegator who deposited collateral.
  """
  delegator: Bytes!
  """
  The delegatee receiving voting power.
  """
  delegatee: Voter!
  """
  The escrow contract holding the delegated gOHM.
  """
  escrow: CoolerDelegateEscrow!
  """
  Delegation amount change (positive = delegated, negative = undelegated).
  """
  amount: BigDecimal!
  """
  The voting power snapshot this event contributed to.
  """
  snapshot: VoterVotingPowerSnapshot!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

"""
This entity tracks the current delegation balance for a delegator-delegatee pair in Cooler V2.
It provides an easy way to query "how much has delegator X delegated to delegatee Y?" without
summing all CoolerDelegationEvent records.

Updated whenever a CoolerDelegationEvent is processed.
"""
type CoolerDelegationBalance @entity {
  """
  Record ID.

  Format: {delegator}-{delegatee}
  """
  id: String!
  """
  The original Cooler V2 delegator who deposited collateral.
  """
  delegator: Bytes!
  """
  The delegatee receiving voting power.
  """
  delegatee: Voter!
  """
  Current total delegated amount from this delegator to this delegatee.
  """
  amount: BigDecimal!
  """
  Block when first delegated.
  """
  blockNumber: BigInt!
  """
  Timestamp when first delegated.
  """
  blockTimestamp: BigInt!
}
